#!/usr/bin/env python3
"""
{{projectName}} - Python Voice Bot with Flask Web Interface
{{description}}

Generated by eleven-cursor CLI
Created: {{timestamp}}
"""

import os
import json
import logging
from datetime import datetime
from flask import Flask, render_template, request, jsonify, send_file
from werkzeug.utils import secure_filename
import requests
from elevenlabs import ElevenLabs
import tempfile
import threading
import time

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'your-secret-key-here')
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size

# Voice configuration
VOICE_CONFIG = {
    'voice_id': '{{voice}}',
    'settings': {
        'stability': 0.75,
        'similarity_boost': 0.75,
        'style': 0.0,
        'use_speaker_boost': True
    }
}

# Initialize ElevenLabs client
try:
    elevenlabs_client = ElevenLabs(api_key=os.environ.get('ELEVEN_API_KEY'))
    logger.info("ElevenLabs client initialized successfully")
except Exception as e:
    logger.error(f"Failed to initialize ElevenLabs client: {e}")
    elevenlabs_client = None

# Global variables for audio generation
generation_status = {}
generation_results = {}

class VoiceBot:
    """Main Voice Bot class for handling voice synthesis and management"""
    
    def __init__(self):
        self.client = elevenlabs_client
        self.voice_id = VOICE_CONFIG['voice_id']
        self.settings = VOICE_CONFIG['settings']
        self.temp_dir = tempfile.mkdtemp()
        
    def generate_voice(self, text, voice_id=None, settings=None):
        """Generate voice from text using ElevenLabs API"""
        try:
            if not self.client:
                raise Exception("ElevenLabs client not initialized")
            
            voice_id = voice_id or self.voice_id
            settings = settings or self.settings
            
            logger.info(f"Generating voice for text: {text[:50]}...")
            
            # Generate audio
            audio = self.client.generate(
                text=text,
                voice=voice_id,
                voice_settings=settings
            )
            
            # Save to temporary file
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"voice_{timestamp}.mp3"
            filepath = os.path.join(self.temp_dir, filename)
            
            with open(filepath, 'wb') as f:
                for chunk in audio:
                    f.write(chunk)
            
            logger.info(f"Voice generated successfully: {filepath}")
            return filepath, filename
            
        except Exception as e:
            logger.error(f"Error generating voice: {e}")
            raise
    
    def get_available_voices(self):
        """Get list of available voices"""
        try:
            if not self.client:
                return []
            
            voices = self.client.voices.get_all()
            return [{'id': voice.voice_id, 'name': voice.name, 'description': voice.description} for voice in voices]
            
        except Exception as e:
            logger.error(f"Error fetching voices: {e}")
            return []
    
    def update_settings(self, new_settings):
        """Update voice settings"""
        self.settings.update(new_settings)
        logger.info(f"Voice settings updated: {self.settings}")
    
    def cleanup_old_files(self, max_age_hours=24):
        """Clean up old temporary files"""
        try:
            current_time = time.time()
            for filename in os.listdir(self.temp_dir):
                filepath = os.path.join(self.temp_dir, filename)
                if os.path.isfile(filepath):
                    file_age = current_time - os.path.getmtime(filepath)
                    if file_age > max_age_hours * 3600:  # Convert hours to seconds
                        os.remove(filepath)
                        logger.info(f"Cleaned up old file: {filename}")
        except Exception as e:
            logger.error(f"Error cleaning up files: {e}")

# Initialize voice bot
voice_bot = VoiceBot()

# Routes
@app.route('/')
def index():
    """Main page"""
    return render_template('index.html', 
                         voice_id=voice_bot.voice_id,
                         settings=voice_bot.settings)

@app.route('/api/voices')
def get_voices():
    """Get available voices"""
    try:
        voices = voice_bot.get_available_voices()
        return jsonify({'success': True, 'voices': voices})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/synthesize', methods=['POST'])
def synthesize():
    """Synthesize text to speech"""
    try:
        data = request.get_json()
        text = data.get('text', '').strip()
        voice_id = data.get('voiceId', voice_bot.voice_id)
        settings = data.get('settings', voice_bot.settings)
        
        if not text:
            return jsonify({'success': False, 'error': 'Text is required'}), 400
        
        if len(text) > 5000:
            return jsonify({'success': False, 'error': 'Text too long (max 5000 characters)'}), 400
        
        # Generate unique ID for this request
        request_id = f"req_{int(time.time() * 1000)}"
        generation_status[request_id] = {'status': 'processing', 'progress': 0}
        
        # Start generation in background thread
        thread = threading.Thread(target=generate_voice_async, args=(request_id, text, voice_id, settings))
        thread.start()
        
        return jsonify({'success': True, 'requestId': request_id})
        
    except Exception as e:
        logger.error(f"Error in synthesize endpoint: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

def generate_voice_async(request_id, text, voice_id, settings):
    """Generate voice asynchronously"""
    try:
        generation_status[request_id]['progress'] = 25
        
        filepath, filename = voice_bot.generate_voice(text, voice_id, settings)
        
        generation_status[request_id]['progress'] = 75
        
        generation_results[request_id] = {
            'status': 'completed',
            'filename': filename,
            'filepath': filepath,
            'text': text,
            'voice_id': voice_id,
            'settings': settings
        }
        
        generation_status[request_id] = {
            'status': 'completed',
            'progress': 100,
            'filename': filename
        }
        
    except Exception as e:
        logger.error(f"Error in async generation: {e}")
        generation_status[request_id] = {
            'status': 'error',
            'progress': 0,
            'error': str(e)
        }

@app.route('/api/status/<request_id>')
def get_status(request_id):
    """Get generation status"""
    if request_id not in generation_status:
        return jsonify({'success': False, 'error': 'Request not found'}), 404
    
    return jsonify({'success': True, 'status': generation_status[request_id]})

@app.route('/api/download/<request_id>')
def download_audio(request_id):
    """Download generated audio"""
    try:
        if request_id not in generation_results:
            return jsonify({'success': False, 'error': 'Audio not found'}), 404
        
        result = generation_results[request_id]
        if result['status'] != 'completed':
            return jsonify({'success': False, 'error': 'Audio not ready'}), 400
        
        return send_file(result['filepath'], as_attachment=True, download_name=result['filename'])
        
    except Exception as e:
        logger.error(f"Error downloading audio: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/settings', methods=['POST'])
def update_settings():
    """Update voice settings"""
    try:
        data = request.get_json()
        new_settings = data.get('settings', {})
        
        # Validate settings
        valid_keys = ['stability', 'similarity_boost', 'style', 'use_speaker_boost']
        for key in new_settings:
            if key not in valid_keys:
                return jsonify({'success': False, 'error': f'Invalid setting: {key}'}), 400
        
        voice_bot.update_settings(new_settings)
        return jsonify({'success': True, 'settings': voice_bot.settings})
        
    except Exception as e:
        logger.error(f"Error updating settings: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/health')
def health_check():
    """Health check endpoint"""
    try:
        status = {
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'elevenlabs_connected': voice_bot.client is not None,
            'voice_id': voice_bot.voice_id,
            'settings': voice_bot.settings
        }
        return jsonify(status)
    except Exception as e:
        return jsonify({'status': 'unhealthy', 'error': str(e)}), 500

# Error handlers
@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500

# Cleanup task
def cleanup_task():
    """Background cleanup task"""
    while True:
        try:
            voice_bot.cleanup_old_files()
            time.sleep(3600)  # Run every hour
        except Exception as e:
            logger.error(f"Error in cleanup task: {e}")
            time.sleep(3600)

# Start cleanup thread
cleanup_thread = threading.Thread(target=cleanup_task, daemon=True)
cleanup_thread.start()

if __name__ == '__main__':
    # Check for required environment variables
    if not os.environ.get('ELEVEN_API_KEY'):
        logger.warning("ELEVEN_API_KEY not set. Voice generation will not work.")
    
    # Run the app
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_ENV') == 'development'
    
    logger.info(f"Starting {{projectName}} on port {port}")
    app.run(host='0.0.0.0', port=port, debug=debug)